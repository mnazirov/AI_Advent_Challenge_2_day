<!DOCTYPE html>
<html lang="ru" class="theme-dark">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Сравнение: с конфигом и без</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; }
    :root {
      --bg: #1a1a1d;
      --bg-elevated: #252529;
      --bg-input: #2d2d32;
      --text: #e4e4e7;
      --text-muted: #71717a;
      --border: #3f3f46;
      --accent: #6366f1;
      --accent-hover: #818cf8;
      --baseline: #71717a;
      --success: #22c55e;
      --error: #ef4444;
      --diff-add: rgba(34, 197, 94, 0.25);
      --diff-remove: rgba(239, 68, 68, 0.25);
    }
    .theme-light {
      --bg: #fafafa;
      --bg-elevated: #fff;
      --bg-input: #fff;
      --text: #18181b;
      --text-muted: #71717a;
      --border: #e4e4e7;
      --accent: #4f46e5;
      --accent-hover: #6366f1;
      --baseline: #52525b;
      --diff-add: rgba(34, 197, 94, 0.2);
      --diff-remove: rgba(239, 68, 68, 0.2);
    }
    body {
      font-family: system-ui, -apple-system, sans-serif;
      margin: 0;
      padding: 0;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      line-height: 1.5;
    }
    .app { max-width: 1400px; margin: 0 auto; padding: 0 1rem 2rem; }
    :root { --chat-block-width: 380px; }

    /* Sticky header */
    .header {
      position: sticky;
      top: 0;
      z-index: 100;
      background: var(--bg);
      border-bottom: 1px solid var(--border);
      padding: 0.75rem 0;
      display: flex;
      align-items: center;
      gap: 1rem;
      flex-wrap: wrap;
    }
    .header h1 { font-size: 1.125rem; font-weight: 600; margin: 0; }
    .header-actions { display: flex; align-items: center; gap: 0.75rem; margin-left: auto; }
    .header-actions > * { height: 2.25rem; box-sizing: border-box; display: inline-flex; align-items: center; }
    .header-actions .btn { padding-top: 0; padding-bottom: 0; }
    .header-actions .eval-preset-select { height: 2.25rem; padding-top: 0; padding-bottom: 0; min-width: 6rem; }
    .status { font-size: 0.875rem; color: var(--text-muted); }
    .status.loading { color: var(--accent); }
    .status-hint { font-size: 0.85rem; color: var(--text-muted, #666); margin-left: 0.5rem; }
    .status.error { color: var(--error); }
    .btn {
      padding: 0.5rem 1rem;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      font-size: 0.875rem;
      font-weight: 500;
      transition: background 0.15s ease, opacity 0.15s ease;
    }
    .btn:focus-visible { outline: 2px solid var(--accent); outline-offset: 2px; }
    .btn-primary { background: var(--accent); color: #fff; }
    .btn-primary:hover:not(:disabled) { background: var(--accent-hover); }
    .btn-secondary { background: var(--bg-elevated); color: var(--text); border: 1px solid var(--border); }
    .btn-secondary:hover:not(:disabled) { background: var(--bg-input); }
    .btn:disabled { opacity: 0.6; cursor: not-allowed; }
    .btn-icon { padding: 0.5rem; }
    .eval-preset-select { padding: 0.4rem 0.5rem; font-size: 0.8125rem; border-radius: 6px; border: 1px solid var(--border); background: var(--bg-elevated); color: var(--text); }

    /* Main layout */
    .main-content { padding-top: 1rem; }
    .input-section { margin-bottom: 1rem; }
    .input-section label { display: block; font-weight: 500; font-size: 0.875rem; margin-bottom: 0.25rem; }
    .textarea-wrap { position: relative; }
    textarea, input[type="text"], input[type="number"], select {
      width: 100%;
      padding: 0.5rem 0.75rem;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--bg-input);
      color: var(--text);
      font: inherit;
      transition: box-shadow 0.15s ease, outline 0.15s ease;
    }
    textarea:focus-visible, input:focus-visible, select:focus-visible {
      outline: none;
      box-shadow: 0 0 0 2px var(--accent);
    }
    textarea { min-height: 120px; resize: vertical; }
    .token-count { font-size: 0.75rem; color: var(--text-muted); margin-top: 0.25rem; }
    .continue-dialog-label { display: inline-flex; align-items: center; gap: 0.35rem; font-size: 0.875rem; font-weight: 500; margin-top: 0.5rem; cursor: pointer; }
    .continue-dialog-label input { margin: 0; }
    .input-hint { display: block; font-size: 0.75rem; color: var(--text-muted); margin-top: 0.15rem; }
    .clear-btn { position: absolute; top: 0.5rem; right: 0.5rem; padding: 0.25rem 0.5rem; font-size: 0.75rem; }

    /* Config panel */
    .config-panel {
      border: 1px solid var(--border);
      border-radius: 8px;
      background: var(--bg-elevated);
      margin-bottom: 1rem;
      overflow: hidden;
    }
    .config-panel-header {
      display: flex; align-items: center; justify-content: space-between;
      padding: 0.5rem 0.75rem;
      cursor: pointer;
      user-select: none;
      font-weight: 500;
    }
    .config-panel-header:hover { background: var(--bg-input); }
    .config-panel-header:focus-visible { outline: 2px solid var(--accent); outline-offset: -2px; }
    .config-panel-body { padding: 0.75rem 1rem; border-top: 1px solid var(--border); }
    .config-panel.collapsed .config-panel-body { display: none; }
    .config-grid { display: grid; gap: 0.75rem; }
    .config-item label { display: block; font-size: 0.8125rem; font-weight: 500; margin-bottom: 0.25rem; }
    .config-section { margin-top: 0.75rem; }
    .config-section-title { font-size: 0.8125rem; font-weight: 600; margin-bottom: 0.5rem; }
    .param-hint { display: block; font-size: 0.75rem; color: var(--text-muted); margin-top: 0.25rem; }
    .param-hint-block { margin-bottom: 0.5rem; }
    .sampling-unavailable-hint { color: var(--baseline); }
    .sampling-fields { display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; }
    .sampling-fields .config-item:last-child:nth-child(odd) { grid-column: span 2; }
    .sampling-fields input:disabled { opacity: 0.6; cursor: not-allowed; }
    .sampling-fields .param-checkbox { display: flex; align-items: center; gap: 0.5rem; }
    .sampling-fields .param-checkbox input[type="checkbox"] { margin: 0; }

    /* Stop sequences tags */
    .stop-tags-wrap {
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--bg-input);
      padding: 0.25rem 0.5rem;
      min-height: 2.5rem;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.25rem;
    }
    .stop-tags-wrap:focus-within { box-shadow: 0 0 0 2px var(--accent); }
    .stop-tag {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      padding: 0.2rem 0.4rem;
      background: var(--accent);
      color: #fff;
      border-radius: 4px;
      font-size: 0.8125rem;
    }
    .stop-tag button {
      background: none; border: none; color: inherit; cursor: pointer;
      padding: 0; line-height: 1; font-size: 1rem; opacity: 0.8;
    }
    .stop-tag button:hover { opacity: 1; }
    .stop-tag button:focus-visible { outline: 2px solid currentColor; outline-offset: 1px; }
    .stop-tags-input {
      flex: 1; min-width: 80px; border: none; background: transparent;
      padding: 0.25rem; font: inherit; color: var(--text);
    }
    .stop-tags-input:focus { outline: none; }
    .stop-tags-hint { font-size: 0.75rem; color: var(--text-muted); margin-top: 0.25rem; }

    /* Horizontal scroll: each chat = one block (config + column), fixed width */
    .chats-and-results-scroll {
      overflow-x: auto;
      overflow-y: visible;
      display: flex;
      gap: 1rem;
      padding-bottom: 0.5rem;
      margin-bottom: 1rem;
      -webkit-overflow-scrolling: touch;
    }
    .chats-and-results-scroll::-webkit-scrollbar { height: 8px; }
    .chats-and-results-scroll::-webkit-scrollbar-track { background: var(--bg-elevated); border-radius: 4px; }
    .chats-and-results-scroll::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }
    .chat-block {
      flex: 0 0 var(--chat-block-width, 380px);
      width: var(--chat-block-width, 380px);
      min-width: var(--chat-block-width, 380px);
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    .chat-card {
      border: 1px solid var(--border);
      border-radius: 8px;
      background: var(--bg-elevated);
      overflow: hidden;
      flex-shrink: 0;
    }
    .chat-card-header {
      display: flex; align-items: center; justify-content: space-between;
      padding: 0.5rem 0.75rem;
      font-weight: 600;
      font-size: 0.875rem;
      border-bottom: 1px solid var(--border);
    }
    .chat-card-header-actions { display: flex; align-items: center; gap: 0.5rem; }
    .chat-card .config-panel { margin-bottom: 0; border: none; border-radius: 0; border-top: 1px solid var(--border); }
    .chat-card .config-panel-header { border-radius: 0; }
    .chat-block .column { flex: 1; min-height: 200px; display: flex; flex-direction: column; }
    .chat-block .column-body { flex: 1; }
    .btn-add-chat { margin-bottom: 1rem; flex-shrink: 0; }
    .btn-remove-chat { font-size: 0.8125rem; padding: 0.25rem 0.5rem; }
    .btn-remove-chat:focus-visible { outline: 2px solid var(--accent); outline-offset: 2px; }

    /* Results header (tabs + diff) */
    .results-wrap { margin-top: 1.5rem; }
    .results-header { display: flex; align-items: center; gap: 1rem; margin-bottom: 0.75rem; flex-wrap: wrap; }
    .tabs-mobile { display: none; }
    @media (max-width: 767px) {
      .tabs-mobile { display: flex; gap: 0.25rem; }
      .tabs-mobile .btn { flex: 1; }
      .chats-and-results-scroll .chat-block .column { display: none; }
      .chats-and-results-scroll .chat-block .column.active { display: flex !important; }
    }
    @media (min-width: 768px) {
      .tabs-mobile { display: none !important; }
      .chats-and-results-scroll .chat-block .column { display: flex !important; }
    }
    .column {
      border: 1px solid var(--border);
      border-radius: 8px;
      background: var(--bg-elevated);
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    .column-header {
      padding: 0.5rem 0.75rem;
      font-weight: 600;
      font-size: 0.875rem;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
    }
    .column-baseline .column-header { color: var(--baseline); }
    .column-with-config .column-header { color: var(--accent); }
    .column-body {
      padding: 0.75rem 1rem;
      flex: 1;
      min-height: 160px;
    }
    .column-body pre, .column-body .response-text {
      word-break: break-word;
      margin: 0;
      font-size: 0.875rem;
      line-height: 1.5;
    }
    .column-body .response-text-plain { white-space: pre-wrap; }
    .column-body .response-text-md { white-space: normal; }
    .column-body .response-text-md p { margin: 0 0 0.5rem; }
    .column-body .response-text-md p:last-child { margin-bottom: 0; }
    .column-body .response-text-md pre.md-block { white-space: pre-wrap; background: var(--bg-elevated); padding: 0.5rem 0.75rem; border-radius: 4px; margin: 0.5rem 0; overflow-x: auto; }
    .column-body .response-text-md code.md-inline { background: var(--bg-elevated); padding: 0.1em 0.35em; border-radius: 3px; font-size: 0.9em; }
    .column-body .response-text-md a { color: var(--accent); text-decoration: underline; }
    .dialog-messages { display: flex; flex-direction: column; gap: 0.75rem; }
    .message { break-inside: avoid; }
    .message-label { font-size: 0.75rem; font-weight: 600; margin-bottom: 0.25rem; }
    .message-user .message-label { color: var(--accent); }
    .message-assistant .message-label { color: var(--baseline); }
    .message-content { white-space: pre-wrap; word-break: break-word; font-size: 0.875rem; line-height: 1.5; }
    .column-body .response-text mark.stop-highlight { background: var(--accent); color: #fff; padding: 0 2px; border-radius: 2px; }
    .column-metrics {
      font-size: 0.75rem;
      color: var(--text-muted);
      padding: 0.5rem 1rem;
      border-top: 1px solid var(--border);
    }
    .column-metrics dl { margin: 0; display: flex; flex-wrap: wrap; gap: 0 1rem; }
    .column-metrics dt { font-weight: 500; }
    .column-metrics dd { margin: 0; }
    .empty-state {
      text-align: center;
      padding: 2rem 1rem;
      color: var(--text-muted);
      font-size: 0.875rem;
    }
    .empty-state svg { width: 48px; height: 48px; margin-bottom: 0.5rem; opacity: 0.5; }

    /* Skeleton */
    .skeleton { background: linear-gradient(90deg, var(--border) 25%, var(--bg-input) 50%, var(--border) 75%); background-size: 200% 100%; animation: skeleton 1.2s ease-in-out infinite; border-radius: 4px; }
    @keyframes skeleton { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }
    .skeleton-line { height: 0.875rem; margin-bottom: 0.5rem; }
    .skeleton-line:last-child { width: 60%; }

    /* Error state */
    .error-inline { color: var(--error); font-size: 0.875rem; }
    .error-inline .retry-btn { margin-top: 0.5rem; }

    /* Diff */
    .diff-toolbar { display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem; flex-wrap: wrap; }
    .diff-view { border: 1px solid var(--border); border-radius: 8px; overflow: hidden; background: var(--bg-elevated); }
    .diff-unified { padding: 1rem; font-size: 0.8125rem; font-family: ui-monospace, monospace; white-space: pre-wrap; word-break: break-word; }
    .diff-unified .add { background: var(--diff-add); }
    .diff-unified .remove { background: var(--diff-remove); }
    .diff-split { display: grid; grid-template-columns: 1fr 1fr; }
    .diff-split .side { padding: 1rem; font-size: 0.8125rem; font-family: ui-monospace, monospace; white-space: pre-wrap; word-break: break-word; border-right: 1px solid var(--border); }
    .diff-split .side:last-child { border-right: none; }
    .diff-split .remove { background: var(--diff-remove); }
    .diff-split .add { background: var(--diff-add); }
    .diff-placeholder { padding: 1rem; color: var(--text-muted); font-size: 0.875rem; }

    /* Drawer */
    .drawer-backdrop {
      position: fixed; inset: 0; background: rgba(0,0,0,0.4);
      z-index: 200; opacity: 0; visibility: hidden;
      transition: opacity 0.2s ease, visibility 0.2s ease;
    }
    .drawer-backdrop.open { opacity: 1; visibility: visible; }
    .drawer {
      position: fixed; top: 0; right: 0; bottom: 0;
      width: min(320px, 100vw);
      background: var(--bg-elevated);
      border-left: 1px solid var(--border);
      z-index: 201;
      transform: translateX(100%);
      transition: transform 0.2s ease;
      display: flex; flex-direction: column;
    }
    .drawer.open { transform: translateX(0); }
    .drawer-header { padding: 1rem; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; }
    .drawer-body { flex: 1; overflow-y: auto; padding: 0.5rem; }
    .history-item {
      padding: 0.75rem; border-radius: 6px; margin-bottom: 0.5rem;
      border: 1px solid var(--border); cursor: pointer;
      font-size: 0.8125rem; transition: background 0.15s ease;
    }
    .history-item:hover { background: var(--bg-input); }
    .history-item:focus-visible { outline: 2px solid var(--accent); outline-offset: -2px; }
    .history-item-preview { color: var(--text-muted); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .history-empty { padding: 1rem; color: var(--text-muted); font-size: 0.875rem; text-align: center; }

    /* Toast */
    .toast-container {
      position: fixed; bottom: 1rem; left: 50%; transform: translateX(-50%);
      z-index: 300; display: flex; flex-direction: column; gap: 0.5rem;
      pointer-events: none;
    }
    .toast {
      padding: 0.5rem 1rem; border-radius: 6px; font-size: 0.875rem;
      background: var(--bg-elevated); border: 1px solid var(--border);
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      opacity: 0; transform: translateY(0.5rem);
      transition: opacity 0.2s ease, transform 0.2s ease;
      pointer-events: auto;
    }
    .toast.show { opacity: 1; transform: translateY(0); }
    .toast.error { border-color: var(--error); color: var(--error); }

    /* Evaluation block */
    .eval-section { margin-top: 1.5rem; border: 1px solid var(--border); border-radius: 8px; background: var(--bg-elevated); overflow: hidden; }
    .eval-toolbar { display: flex; align-items: center; gap: 0.75rem; flex-wrap: wrap; padding: 0.75rem 1rem; border-bottom: 1px solid var(--border); }
    .eval-winner { padding: 1rem 1rem; font-weight: 600; font-size: 1rem; color: var(--accent); border-bottom: 1px solid var(--border); }
    .eval-subtitle { font-size: 0.9375rem; font-weight: 600; color: var(--text-muted); margin: 0 0 0.5rem 0; }
    .eval-subtitle-top2 { margin-top: 1rem; }
    .eval-ranking { padding: 1rem; }
    .eval-ranking .eval-table { width: 100%; border-collapse: collapse; font-size: 0.875rem; }
    .eval-ranking .eval-table thead { background: var(--bg-input); }
    .eval-ranking .eval-table th, .eval-ranking .eval-table td { padding: 0.5rem 0.75rem; text-align: left; border-bottom: 1px solid var(--border); }
    .eval-ranking .eval-table .eval-th-score, .eval-ranking .eval-table .eval-td-score { text-align: right; }
    .eval-ranking .eval-table tbody tr:nth-child(even) { background: var(--bg-input); }
    .eval-details { padding: 1rem; }
    .eval-criteria-list { margin: 0; padding-left: 1.2rem; }
    .eval-run-card { border: 1px solid var(--border); border-radius: 6px; margin-bottom: 0.75rem; overflow: hidden; }
    .eval-run-card:last-child { margin-bottom: 0; }
    .eval-run-header { width: 100%; padding: 0.6rem 0.75rem; cursor: pointer; display: flex; justify-content: space-between; align-items: center; font-weight: 500; font-size: 0.875rem; text-align: left; border: none; background: var(--bg-elevated); color: inherit; }
    .eval-run-header:hover { background: var(--bg-input); }
    .eval-run-header:focus-visible { outline: 2px solid var(--accent); outline-offset: 2px; }
    .eval-run-body { padding: 0.75rem 1rem; border-top: 1px solid var(--border); font-size: 0.8125rem; background: var(--bg); }
    .eval-run-body dl { margin: 0.35rem 0; }
    .eval-run-body dt { font-weight: 600; color: var(--text-muted); font-size: 0.8125rem; }
    .eval-top2-card { border: 1px solid var(--accent); border-radius: 6px; overflow: hidden; background: var(--bg); }
    .eval-top2-card .eval-run-body { border-top: none; }
    .eval-badges { display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center; }
    .eval-badge { font-size: 0.75rem; padding: 0.25rem 0.5rem; border-radius: 4px; background: var(--bg-input); color: var(--text-muted); }
    .eval-badge.fallback { background: var(--baseline); color: var(--bg); }
    .eval-badge.confidence { background: var(--accent); color: #fff; }

    /* API debug: request/response JSON */
    .api-debug-section { margin-top: 1rem; }
    .api-debug-section .btn { margin-bottom: 0.5rem; }
    .api-debug-content { border: 1px solid var(--border); border-radius: 6px; background: var(--bg); padding: 1rem; overflow: auto; }
    .api-debug-heading { font-size: 0.875rem; font-weight: 600; margin: 0 0 0.35rem 0; color: var(--text-muted); }
    .api-debug-content .api-debug-heading:not(:first-child) { margin-top: 1rem; }
    .api-debug-pre { margin: 0; font-size: 0.75rem; line-height: 1.4; white-space: pre-wrap; word-break: break-all; color: var(--text); background: var(--bg-elevated); padding: 0.75rem; border-radius: 4px; max-height: 20rem; overflow: auto; }

    /* Utility */
    .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,0,0); border: 0; }
  </style>
</head>
<body>
  <div class="app">
    <header class="header" role="banner">
      <h1>Сравнение запросов: несколько чатов</h1>
      <div class="header-actions">
        <span id="status" class="status" aria-live="polite">Готов</span>
        <span id="statusHint" class="status-hint" style="display:none;" aria-live="polite"></span>
        <button type="button" class="btn btn-secondary" id="historyBtn" aria-label="История запросов" title="История">История</button>
        <button type="button" class="btn btn-secondary" id="themeBtn" aria-label="Переключить тему">Тема</button>
        <button type="button" class="btn btn-secondary" id="newDialogBtn" aria-label="Новый диалог">Новый диалог</button>
        <select id="evalPreset" class="eval-preset-select" aria-label="Пресет критериев оценки" title="Код / Факты / Текст / Общий">
          <option value="general">Общий</option>
          <option value="code">Код</option>
          <option value="factual">Факты</option>
          <option value="writing">Текст</option>
        </select>
        <button type="button" class="btn btn-secondary" id="evaluateBtn" aria-label="Оценить ответы">Оценить</button>
        <button type="submit" form="form" id="submitBtn" class="btn btn-primary">Run</button>
      </div>
    </header>

    <main class="main-content">
      <form id="form">
        <div class="input-section">
          <label for="user_message">Сообщение пользователя *</label>
          <div class="textarea-wrap">
            <textarea id="user_message" name="user_message" required placeholder="Введите запрос к модели..." aria-describedby="token_count"></textarea>
            <button type="button" class="btn btn-secondary clear-btn" id="clearUserMsg" aria-label="Очистить поле">Очистить</button>
          </div>
          <div id="token_count" class="token-count" aria-live="polite">~0 токенов</div>
          <label class="continue-dialog-label">
            <input type="checkbox" id="continueDialog" name="continue_dialog" checked aria-describedby="continue_dialog_hint" />
            <span>Продолжить диалог</span>
          </label>
          <span id="continue_dialog_hint" class="input-hint">Если выключено, запрос отправится без истории (один тур)</span>
        </div>

        <div class="results-header">
          <div class="tabs-mobile" id="tabsMobile" role="tablist"></div>
          <div class="diff-toolbar" id="diffToolbar" style="display: none;">
            <button type="button" class="btn btn-secondary" id="showDiffBtn">Show Diff</button>
            <button type="button" class="btn btn-secondary" id="hideDiffBtn" style="display: none;">Hide Diff</button>
            <div id="diffModeSwitch" style="display: none;">
              <button type="button" class="btn btn-secondary btn-icon diff-mode-btn active" data-mode="unified" aria-pressed="true">Unified</button>
              <button type="button" class="btn btn-secondary btn-icon diff-mode-btn" data-mode="split" aria-pressed="false">Split</button>
            </div>
          </div>
        </div>

        <div class="chats-and-results-scroll" id="chatsAndResultsScroll" aria-label="Чаты и результаты"></div>
        <button type="button" class="btn btn-secondary btn-add-chat" id="addChatBtn" aria-label="Добавить чат">Добавить чат</button>
      </form>

      <div class="api-debug-section" id="apiDebugSection" style="display: none;">
        <button type="button" class="btn btn-secondary" id="apiDebugToggle" aria-expanded="false" aria-controls="apiDebugContent">Запрос и ответ</button>
        <div class="api-debug-content" id="apiDebugContent" style="display: none;">
          <h4 class="api-debug-heading">Отправленный JSON</h4>
          <pre id="apiDebugRequest" class="api-debug-pre"></pre>
          <h4 class="api-debug-heading">Ответ</h4>
          <pre id="apiDebugResponse" class="api-debug-pre"></pre>
        </div>
      </div>

      <div class="results-wrap" id="resultsView">
        <div class="diff-view" id="diffView" style="display: none;">
          <div id="diffContent"></div>
        </div>
      </div>

      <section class="eval-section" id="evalSection" style="display: none;" aria-label="Результаты оценки">
        <div class="eval-toolbar">
          <span class="eval-badges" id="evalBadges"></span>
        </div>
        <div class="eval-winner" id="evalWinner"></div>
        <div class="eval-ranking" id="evalRanking"></div>
        <div class="eval-details" id="evalDetails"></div>
      </section>
    </main>
  </div>

  <div class="drawer-backdrop" id="drawerBackdrop" aria-hidden="true"></div>
  <aside class="drawer" id="drawer" role="dialog" aria-label="История запросов" aria-hidden="true">
    <div class="drawer-header">
      <h2 style="margin:0; font-size:1rem;">История</h2>
      <button type="button" class="btn btn-secondary btn-icon" id="drawerClose" aria-label="Закрыть">×</button>
    </div>
    <div class="drawer-body" id="historyList"></div>
  </aside>

  <div class="toast-container" id="toastContainer" aria-live="polite"></div>

  <script>
  window.MODELS_WITHOUT_SAMPLING = {{ models_without_sampling|tojson }};
  window.CHAT_MODELS = {{ models|tojson }};
  window.DEFAULT_CHAT_MODEL = {{ default_model|tojson }};
  </script>
  <script>
(function() {
  const MODELS_WITHOUT_SAMPLING = new Set(window.MODELS_WITHOUT_SAMPLING || []);
  const CHAT_MODELS = window.CHAT_MODELS || [];
  const DEFAULT_CHAT_MODEL = window.DEFAULT_CHAT_MODEL || (CHAT_MODELS[0] || 'gpt-4o-mini');
  const STORAGE_KEYS = {
    configCollapsed: 'compare_config_panel_collapsed',
    theme: 'compare_theme',
    history: 'compare_history',
    settings: 'compare_settings',
  };
  const MAX_HISTORY = 10;
  const MAX_RUNS = 10;
  const MAX_STOP_SEQUENCES = 4;
  const TOKEN_DEBOUNCE_MS = 300;
  const FETCH_TIMEOUT_MS = 180000; // 3 min; abort fetch after this, show timeout message

  function getDefaultConfig() {
    return {
      system_prompt: '',
      stop_sequences: [],
      max_output_tokens: null,
      model: DEFAULT_CHAT_MODEL,
      temperature_enabled: false,
      temperature: null,
      top_p_enabled: false,
      top_p: null,
      frequency_penalty_enabled: false,
      frequency_penalty: null,
      presence_penalty_enabled: false,
      presence_penalty: null,
      seed_enabled: false,
      seed: null,
    };
  }

  let nextChatId = 1;
  let chats = [{ id: 'chat_0', name: null, config: getDefaultConfig(), messages: [] }];
  const scrollContainer = document.getElementById('chatsAndResultsScroll');
  const addChatBtn = document.getElementById('addChatBtn');

  function getChatLabel(chat, index) {
    return (chat.name && String(chat.name).trim()) ? String(chat.name).trim() : ('Чат ' + (index + 1));
  }

  function getColumnEl(index) {
    return scrollContainer.querySelector('.chat-block[data-chat-index="' + index + '"] .column');
  }

  function escapeHtml(s) {
    const div = document.createElement('div');
    div.textContent = s;
    return div.innerHTML;
  }

  /** Minimal markdown to HTML (safe: escapes then applies patterns). Supports **bold**, *italic*, `code`, ```blocks```, [links](url), paragraphs. */
  function markdownToHtml(text) {
    if (!text || typeof text !== 'string') return '';
    const codeBlocks = [];
    let t = text.replace(/```(\w*)\n?([\s\S]*?)```/g, (_, lang, code) => {
      const i = codeBlocks.length;
      codeBlocks.push(escapeHtml(code).trim());
      return '\n%%CB' + i + '%%\n';
    });
    t = escapeHtml(t).replace(/%%CB(\d+)%%/g, (_, i) => '<pre class="md-block"><code>' + codeBlocks[Number(i)] + '</code></pre>');
    t = t.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>').replace(/\*([^*]+)\*/g, '<em>$1</em>').replace(/`([^`]+)`/g, '<code class="md-inline">$1</code>');
    t = t.replace(/\[([^\]]+)\]\((https?:\/\/[^)\s]+)\)/g, (_, label, href) => '<a href="' + escapeHtml(href) + '" target="_blank" rel="noopener noreferrer">' + escapeHtml(label) + '</a>');
    t = t.replace(/\n\n+/g, '</p><p>').replace(/\n/g, '<br>');
    return '<p>' + t + '</p>';
  }

  function renderMessageContent(text, stopSeqs) {
    if (!text || typeof text !== 'string') return '';
    if (!stopSeqs || !stopSeqs.length) return markdownToHtml(text);
    const parts = [];
    let pos = 0;
    for (let i = 0; i < stopSeqs.length; i++) {
      const idx = text.indexOf(stopSeqs[i], pos);
      if (idx === -1) continue;
      if (idx > pos) parts.push({ t: text.slice(pos, idx), stop: false });
      parts.push({ t: stopSeqs[i], stop: true });
      pos = idx + stopSeqs[i].length;
    }
    if (pos < text.length) parts.push({ t: text.slice(pos), stop: false });
    return parts.map(p => p.stop ? '<mark class="stop-highlight">' + escapeHtml(p.t) + '</mark>' : markdownToHtml(p.t)).join('');
  }

  function approxTokens(text) {
    if (!text || !text.trim()) return 0;
    return Math.ceil(text.trim().length / 4);
  }

  function toast(message, isError) {
    const container = document.getElementById('toastContainer');
    const el = document.createElement('div');
    el.className = 'toast' + (isError ? ' error' : '');
    el.textContent = message;
    container.appendChild(el);
    requestAnimationFrame(() => el.classList.add('show'));
    setTimeout(() => {
      el.classList.remove('show');
      setTimeout(() => el.remove(), 200);
    }, 3500);
  }

  function setStatus(text, className) {
    const status = document.getElementById('status');
    status.textContent = text;
    status.className = 'status' + (className ? ' ' + className : '');
    const hint = document.getElementById('statusHint');
    if (hint) {
      if (className === 'loading') {
        hint.textContent = 'При нескольких чатах ответ может занять 1–2 минуты';
        hint.style.display = '';
      } else {
        hint.style.display = 'none';
        hint.textContent = '';
      }
    }
  }

  const userMessageEl = document.getElementById('user_message');
  const tokenCountEl = document.getElementById('token_count');
  let tokenDebounce;
  userMessageEl.addEventListener('input', () => {
    clearTimeout(tokenDebounce);
    tokenDebounce = setTimeout(() => {
      tokenCountEl.textContent = '~' + approxTokens(userMessageEl.value) + ' токенов';
      saveSettings();
    }, TOKEN_DEBOUNCE_MS);
  });
  document.getElementById('clearUserMsg').addEventListener('click', () => {
    userMessageEl.value = '';
    tokenCountEl.textContent = '~0 токенов';
    saveSettings();
  });

  function saveSettings() {
    try {
      const payload = { user_message: userMessageEl.value };
      localStorage.setItem(STORAGE_KEYS.settings, JSON.stringify(payload));
    } catch (_) {}
  }
  function loadSettings() {
    try {
      const raw = localStorage.getItem(STORAGE_KEYS.settings);
      if (!raw) return;
      const payload = JSON.parse(raw);
      if (payload.user_message != null) userMessageEl.value = payload.user_message;
      tokenCountEl.textContent = '~' + approxTokens(userMessageEl.value) + ' токенов';
    } catch (_) {}
  }

  function samplingParamRow(field, label, enabled, value, min, max, step, placeholder, chatId) {
    const val = (enabled && value != null && String(value).trim() !== '') ? escapeHtml(String(value)) : '';
    const dis = enabled ? '' : ' disabled';
    const minAttr = min !== '' ? ' min="' + escapeHtml(min) + '"' : '';
    const maxAttr = max !== '' ? ' max="' + escapeHtml(max) + '"' : '';
    const stepAttr = step !== '' ? ' step="' + escapeHtml(step) + '"' : '';
    return '<div class="config-item"><div class="param-checkbox"><input type="checkbox" data-field="' + field + '_enabled" id="' + field + '_' + escapeHtml(chatId) + '"' + (enabled ? ' checked' : '') + ' aria-label="Включить ' + escapeHtml(label) + '" /><label for="' + field + '_' + escapeHtml(chatId) + '">' + escapeHtml(label) + '</label></div><input type="number" data-field="' + field + '"' + minAttr + maxAttr + stepAttr + ' placeholder="' + escapeHtml(placeholder) + '" value="' + val + '"' + dis + ' /></div>';
  }

  function buildConfigBody(chat, chatId) {
    const c = chat.config;
    const modelOptions = CHAT_MODELS.map(m => '<option value="' + escapeHtml(m) + '"' + (c.model === m ? ' selected' : '') + '>' + escapeHtml(m) + '</option>').join('');
    const stopTagsHtml = (c.stop_sequences || []).slice(0, MAX_STOP_SEQUENCES).map((s, i) =>
      '<span class="stop-tag">' + escapeHtml(s) + ' <button type="button" data-index="' + i + '" aria-label="Удалить">×</button></span>'
    ).join('');
    return '<div class="config-grid">' +
      '<div class="config-item"><label for="sp_' + escapeHtml(chatId) + '">System Prompt</label><textarea id="sp_' + escapeHtml(chatId) + '" data-field="system_prompt" placeholder="Инструкции для модели (опционально)" rows="3">' + escapeHtml(c.system_prompt || '') + '</textarea></div>' +
      '<div class="config-item"><label>Stop Sequences (до 4)</label><div class="stop-tags-wrap" data-field="stop-wrap"><div class="stop-tags-list" style="display:contents">' + stopTagsHtml + '</div><input type="text" class="stop-tags-input" data-field="stop-input" placeholder="Добавить..." aria-label="Добавить stop sequence" /></div><div class="stop-tags-hint">Максимум 4 последовательности</div></div>' +
      '<div class="config-item"><label for="max_' + escapeHtml(chatId) + '">Max output tokens</label><input type="number" id="max_' + escapeHtml(chatId) + '" data-field="max_output_tokens" min="1" max="4096" placeholder="512" value="' + (c.max_output_tokens != null && c.max_output_tokens !== '' ? escapeHtml(String(c.max_output_tokens)) : '') + '" /></div>' +
      '<div class="config-section"><div class="config-section-title">Сэмплирование</div><p class="param-hint param-hint-block sampling-unavailable-hint" data-field="sampling-hint" style="display:none;">Для выбранной модели недоступно.</p><div class="config-grid sampling-fields">' +
      samplingParamRow('temperature', 'Temperature', c.temperature_enabled, c.temperature, '0', '2', '0.1', '0.7', chatId) +
      samplingParamRow('top_p', 'Top P', c.top_p_enabled, c.top_p, '0', '1', '0.01', '1', chatId) +
      samplingParamRow('frequency_penalty', 'Frequency penalty', c.frequency_penalty_enabled, c.frequency_penalty, '-2', '2', '0.1', '0', chatId) +
      samplingParamRow('presence_penalty', 'Presence penalty', c.presence_penalty_enabled, c.presence_penalty, '-2', '2', '0.1', '0', chatId) +
      samplingParamRow('seed', 'Seed', c.seed_enabled, c.seed, '', '', '', 'опционально', chatId) +
      '</div></div><div class="config-item"><label for="model_' + escapeHtml(chatId) + '">Модель</label><select id="model_' + escapeHtml(chatId) + '" data-field="model">' + modelOptions + '</select></div></div>';
  }

  function updateSamplingAvailabilityInCard(card) {
    const model = (card.querySelector('[data-field="model"]') || {}).value;
    const unavailable = MODELS_WITHOUT_SAMPLING.has(model);
    ['temperature', 'top_p', 'frequency_penalty', 'presence_penalty', 'seed'].forEach(f => {
      const check = card.querySelector('[data-field="' + f + '_enabled"]');
      const el = card.querySelector('[data-field="' + f + '"]');
      if (check) check.disabled = unavailable;
      if (el) el.disabled = unavailable || !(check && check.checked);
    });
    const hint = card.querySelector('[data-field="sampling-hint"]');
    if (hint) hint.style.display = unavailable ? 'block' : 'none';
  }

  function bindCardToChat(card, chat, index) {
    const chatId = chat.id;
    const samplingFields = ['temperature', 'top_p', 'frequency_penalty', 'presence_penalty', 'seed'];
    const updateConfig = () => {
      const cfg = chat.config;
      const sp = card.querySelector('[data-field="system_prompt"]');
      if (sp) cfg.system_prompt = sp.value || '';
      const maxEl = card.querySelector('[data-field="max_output_tokens"]');
      if (maxEl) { const v = maxEl.value.trim(); cfg.max_output_tokens = v ? parseInt(v, 10) : null; }
      cfg.model = (card.querySelector('[data-field="model"]') || {}).value || null;
      samplingFields.forEach(f => {
        const check = card.querySelector('[data-field="' + f + '_enabled"]');
        const el = card.querySelector('[data-field="' + f + '"]');
        const enabled = check && check.checked;
        cfg[f + '_enabled'] = !!enabled;
        cfg[f] = enabled && el ? (el.value.trim() || null) : null;
      });
      updateSamplingAvailabilityInCard(card);
    };
    function toggleSamplingInput(field) {
      const check = card.querySelector('[data-field="' + field + '_enabled"]');
      const el = card.querySelector('[data-field="' + field + '"]');
      if (!el || !check) return;
      if (check.checked) {
        el.disabled = false;
      } else {
        el.disabled = true;
        el.value = '';
      }
      updateConfig();
    }
    card.querySelectorAll('[data-field="system_prompt"], [data-field="max_output_tokens"], [data-field="model"]').forEach(el => {
      el.addEventListener('change', updateConfig);
      el.addEventListener('input', updateConfig);
    });
    samplingFields.forEach(f => {
      const check = card.querySelector('[data-field="' + f + '_enabled"]');
      const el = card.querySelector('[data-field="' + f + '"]');
      if (check) { check.addEventListener('change', () => toggleSamplingInput(f)); }
      if (el) { el.addEventListener('change', updateConfig); el.addEventListener('input', updateConfig); }
    });
    const modelSelect = card.querySelector('[data-field="model"]');
    if (modelSelect) modelSelect.addEventListener('change', () => {
      updateConfig();
      if (MODELS_WITHOUT_SAMPLING.has(chat.config.model)) {
        samplingFields.forEach(f => {
          chat.config[f + '_enabled'] = false;
          chat.config[f] = null;
          const check = card.querySelector('[data-field="' + f + '_enabled"]');
          const el = card.querySelector('[data-field="' + f + '"]');
          if (check) check.checked = false;
          if (el) el.value = '';
        });
      }
      updateSamplingAvailabilityInCard(card);
    });
    const stopWrap = card.querySelector('[data-field="stop-wrap"]');
    const stopList = stopWrap && stopWrap.querySelector('.stop-tags-list');
    const stopInput = stopWrap && stopWrap.querySelector('[data-field="stop-input"]');
    function renderStopTags() {
      if (!stopList) return;
      stopList.innerHTML = (chat.config.stop_sequences || []).slice(0, MAX_STOP_SEQUENCES).map((s, i) =>
        '<span class="stop-tag">' + escapeHtml(s) + ' <button type="button" data-index="' + i + '" aria-label="Удалить">×</button></span>'
      ).join('');
    }
    function addStop(val) {
      const v = (val || '').trim();
      if (!v || (chat.config.stop_sequences || []).length >= MAX_STOP_SEQUENCES) return;
      if (!chat.config.stop_sequences) chat.config.stop_sequences = [];
      if (chat.config.stop_sequences.includes(v)) return;
      chat.config.stop_sequences.push(v);
      renderStopTags();
      if (stopInput) stopInput.value = '';
    }
    if (stopInput) {
      stopInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ',') { e.preventDefault(); addStop(e.key === ',' ? stopInput.value.replace(/,+\s*$/, '') : stopInput.value); }
      });
      stopInput.addEventListener('blur', () => { if (stopInput.value.trim()) addStop(stopInput.value); });
    }
    if (stopWrap) stopWrap.addEventListener('click', (e) => {
      const idx = e.target.getAttribute('data-index');
      if (idx != null && chat.config.stop_sequences) {
        chat.config.stop_sequences.splice(parseInt(idx, 10), 1);
        renderStopTags();
      }
    });
    const nameInput = card.querySelector('[data-field="chat_name"]');
    if (nameInput) {
      nameInput.addEventListener('input', () => {
        chat.name = nameInput.value.trim() || null;
        const block = card.closest('.chat-block');
        const titleEl = block && block.querySelector('.column-title');
        if (titleEl) titleEl.textContent = getChatLabel(chat, index);
        const tabEl = document.getElementById('tab-' + chat.id);
        if (tabEl) tabEl.textContent = getChatLabel(chat, index);
      });
      nameInput.addEventListener('change', () => {
        chat.name = nameInput.value.trim() || null;
        const block = card.closest('.chat-block');
        const titleEl = block && block.querySelector('.column-title');
        if (titleEl) titleEl.textContent = getChatLabel(chat, index);
        const tabEl = document.getElementById('tab-' + chat.id);
        if (tabEl) tabEl.textContent = getChatLabel(chat, index);
      });
    }
    updateSamplingAvailabilityInCard(card);
  }

  function renderChatBlocks() {
    scrollContainer.innerHTML = '';
    chats.forEach((chat, index) => {
      const block = document.createElement('div');
      block.className = 'chat-block';
      block.setAttribute('data-chat-index', String(index));
      block.setAttribute('data-chat-id', chat.id);

      const card = document.createElement('div');
      card.className = 'chat-card';
      const defaultLabel = 'Чат ' + (index + 1);
      const canDelete = chats.length > 1;
      card.innerHTML = '<div class="chat-card-header"><input type="text" class="chat-name-input" data-field="chat_name" placeholder="' + escapeHtml(defaultLabel) + '" value="' + escapeHtml(chat.name || '') + '" aria-label="Название чата" /><div class="chat-card-header-actions">' +
        (canDelete ? '<button type="button" class="btn btn-secondary btn-remove-chat" aria-label="Удалить чат">Удалить</button>' : '') +
        '</div></div><div class="config-panel collapsed"><button type="button" class="config-panel-header" aria-expanded="false" aria-controls="config-body-' + escapeHtml(chat.id) + '">Настройки <span aria-hidden="true" class="config-chevron">▶</span></button><div class="config-panel-body" id="config-body-' + escapeHtml(chat.id) + '">' + buildConfigBody(chat, chat.id) + '</div></div>';

      const col = document.createElement('div');
      col.className = 'column' + (index === 0 ? ' active' : '');
      col.setAttribute('data-column', chat.id);
      col.setAttribute('data-chat-index', String(index));
      col.setAttribute('role', 'tabpanel');
      col.setAttribute('aria-labelledby', 'tab-' + chat.id);
      col.id = 'panel-' + chat.id;
      col.innerHTML = '<div class="column-header"><span class="column-title">' + escapeHtml(getChatLabel(chat, index)) + '</span> <button type="button" class="btn btn-secondary btn-icon copy-btn" data-chat-index="' + index + '" aria-label="Копировать ответ">Копировать</button></div>' +
        '<div class="column-body"><div class="empty-state column-empty"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-5l-5 5v-5z"/></svg><p>Ответ появится здесь</p></div><div class="column-content" style="display:none;"></div></div>' +
        '<div class="column-metrics" style="display:none;"></div>';

      const toggle = card.querySelector('.config-panel-header');
      const chevron = card.querySelector('.config-chevron');
      const panel = card.querySelector('.config-panel');
      toggle.addEventListener('click', () => {
        const collapsed = panel.classList.toggle('collapsed');
        toggle.setAttribute('aria-expanded', collapsed ? 'false' : 'true');
        if (chevron) chevron.textContent = collapsed ? '▶' : '▼';
      });
      card.querySelector('.btn-remove-chat') && card.querySelector('.btn-remove-chat').addEventListener('click', () => {
        if (chats.length <= 1) return;
        chats.splice(index, 1);
        lastResults.splice(index, 1);
        renderChatBlocks();
        renderTabsMobile();
        updateDiffToolbarVisibility();
      });
      bindCardToChat(card, chat, index);

      col.querySelector('.copy-btn').addEventListener('click', () => {
        const text = lastResults[index] && lastResults[index].text;
        if (!text) return;
        navigator.clipboard.writeText(text).then(() => toast('Скопировано'), () => toast('Не удалось скопировать', true));
      });

      block.appendChild(card);
      block.appendChild(col);
      scrollContainer.appendChild(block);
    });

    chats.forEach((chat, index) => {
      const col = getColumnEl(index);
      if (col) renderDialogColumn(index, chat.messages, lastResults[index] || null);
    });
  }

  addChatBtn.addEventListener('click', () => {
    if (chats.length >= MAX_RUNS) { toast('Максимум ' + MAX_RUNS + ' чатов', true); return; }
    chats.push({ id: 'chat_' + (nextChatId++), name: null, config: getDefaultConfig(), messages: [] });
    renderChatBlocks();
    renderTabsMobile();
    updateDiffToolbarVisibility();
  });

  loadSettings();

  let lastResults = []; // per-chat last response { text, usage, finish_reason } for diff/copy

  function clearDialog() {
    chats.forEach(c => { c.messages = []; });
    lastResults = [];
    document.getElementById('diffToolbar').style.display = 'none';
    updateDiffVisibility(false);
    renderChatBlocks();
  }
  document.getElementById('newDialogBtn').addEventListener('click', clearDialog);

  document.getElementById('themeBtn').addEventListener('click', () => {
    const html = document.documentElement;
    const isDark = html.classList.toggle('theme-dark');
    html.classList.toggle('theme-light', !isDark);
    try { localStorage.setItem(STORAGE_KEYS.theme, isDark ? 'dark' : 'light'); } catch (_) {}
  });
  const savedTheme = localStorage.getItem(STORAGE_KEYS.theme);
  if (savedTheme === 'light') {
    document.documentElement.classList.remove('theme-dark');
    document.documentElement.classList.add('theme-light');
  }

  function getRunConfig(chat) {
    const c = chat.config;
    function parseFloat_(val, lo, hi) {
      if (val == null || String(val).trim() === '') return null;
      const n = parseFloat(val);
      if (isNaN(n)) return null;
      return Math.max(lo, Math.min(hi, n));
    }
    const out = {
      system_prompt: (c.system_prompt || '').trim() || null,
      stop_sequences: (c.stop_sequences || []).slice(0, MAX_STOP_SEQUENCES),
      max_output_tokens: c.max_output_tokens != null && c.max_output_tokens >= 1 ? Math.min(4096, c.max_output_tokens) : null,
      model: (c.model || '').trim() || DEFAULT_CHAT_MODEL,
    };
    if (!MODELS_WITHOUT_SAMPLING.has(out.model)) {
      if (c.temperature_enabled) { const v = parseFloat_(c.temperature, 0, 2); if (v != null) out.temperature = v; }
      if (c.top_p_enabled) { const v = parseFloat_(c.top_p, 0, 1); if (v != null) out.top_p = v; }
      if (c.frequency_penalty_enabled) { const v = parseFloat_(c.frequency_penalty, -2, 2); if (v != null) out.frequency_penalty = v; }
      if (c.presence_penalty_enabled) { const v = parseFloat_(c.presence_penalty, -2, 2); if (v != null) out.presence_penalty = v; }
      if (c.seed_enabled) { const v = c.seed; if (v != null && String(v).trim() !== '') { const n = parseInt(v, 10); if (!isNaN(n)) out.seed = n; } }
    }
    return out;
  }

  function renderTabsMobile() {
    const container = document.getElementById('tabsMobile');
    container.innerHTML = '';
    if (chats.length === 0) return;
    chats.forEach((chat, i) => {
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.id = 'tab-' + chat.id;
      btn.className = 'btn btn-secondary tabs-mobile-btn' + (i === 0 ? ' active' : '');
      btn.setAttribute('data-tab', chat.id);
      btn.setAttribute('role', 'tab');
      btn.setAttribute('aria-selected', i === 0 ? 'true' : 'false');
      btn.setAttribute('aria-controls', 'panel-' + chat.id);
      btn.textContent = getChatLabel(chat, i);
      container.appendChild(btn);
    });
    container.querySelectorAll('.tabs-mobile-btn').forEach((tab, i) => {
      tab.addEventListener('click', () => {
        container.querySelectorAll('.tabs-mobile-btn').forEach((t, j) => { t.classList.toggle('active', j === i); t.setAttribute('aria-selected', j === i ? 'true' : 'false'); });
        scrollContainer.querySelectorAll('.chat-block .column').forEach((col, j) => { col.classList.toggle('active', j === i); });
      });
    });
  }

  function updateDiffToolbarVisibility() {
    const diffToolbar = document.getElementById('diffToolbar');
    diffToolbar.style.display = chats.length === 2 ? 'flex' : 'none';
    if (chats.length !== 2) updateDiffVisibility(false);
  }

  function showSkeleton(index) {
    const col = getColumnEl(index);
    if (!col) return;
    const empty = col.querySelector('.column-empty');
    const content = col.querySelector('.column-content');
    const metrics = col.querySelector('.column-metrics');
    if (empty) empty.style.display = 'none';
    if (content) { content.style.display = 'block'; content.innerHTML = '<div class="skeleton skeleton-line"></div><div class="skeleton skeleton-line"></div><div class="skeleton skeleton-line"></div>'; }
    if (metrics) metrics.style.display = 'none';
  }

  function highlightStopSequences(text, stops) {
    if (!text || !stops || stops.length === 0) return escapeHtml(text);
    let out = '';
    let pos = 0;
    const segments = [];
    for (let i = 0; i < stops.length; i++) {
      const idx = text.indexOf(stops[i], pos);
      if (idx !== -1) {
        if (idx > pos) segments.push({ t: text.slice(pos, idx), stop: false });
        segments.push({ t: stops[i], stop: true });
        pos = idx + stops[i].length;
      }
    }
    if (pos < text.length) segments.push({ t: text.slice(pos), stop: false });
    segments.forEach(s => {
      out += s.stop ? '<mark class="stop-highlight">' + escapeHtml(s.t) + '</mark>' : escapeHtml(s.t);
    });
    return out || escapeHtml(text);
  }

  function typewriter(el, text, stopSequencesForHighlight, done) {
    el.innerHTML = '';
    const container = document.createElement('pre');
    container.className = 'response-text response-text-plain';
    el.appendChild(container);
    if (!text) {
      container.textContent = '(пусто)';
      if (done) done();
      return;
    }
    const chunk = 2;
    let i = 0;
    function tick() {
      if (i >= text.length) {
        const mdContainer = document.createElement('div');
        mdContainer.className = 'response-text response-text-md';
        mdContainer.innerHTML = renderMessageContent(text, stopSequencesForHighlight || null);
        container.replaceWith(mdContainer);
        if (done) done();
        return;
      }
      i += chunk;
      const slice = text.slice(0, i);
      container.textContent = slice;
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);
  }

  function renderDialogColumn(index, messages, lastResult) {
    const col = getColumnEl(index);
    if (!col) return;
    const empty = col.querySelector('.column-empty');
    const content = col.querySelector('.column-content');
    const metricsEl = col.querySelector('.column-metrics');

    if (!messages || messages.length === 0) {
      if (empty) empty.style.display = 'block';
      if (content) { content.style.display = 'none'; content.innerHTML = ''; }
      if (metricsEl) metricsEl.style.display = 'none';
      return;
    }
    if (empty) empty.style.display = 'none';
    if (content) content.style.display = 'block';
    if (metricsEl) metricsEl.style.display = 'none';

    const lastIsAssistant = messages.length > 0 && messages[messages.length - 1].role === 'assistant';
    const lastAssistantData = lastIsAssistant && lastResult ? lastResult : null;
    const chat = chats[index];
    const stopForHighlight = chat && chat.config && chat.config.stop_sequences && chat.config.stop_sequences.length ? chat.config.stop_sequences : null;

    const wrap = document.createElement('div');
    wrap.className = 'dialog-messages';
    for (let i = 0; i < messages.length; i++) {
      const msg = messages[i];
      const isLast = i === messages.length - 1;
      const div = document.createElement('div');
      div.className = 'message message-' + msg.role;
      div.innerHTML = '<div class="message-label">' + (msg.role === 'user' ? 'User' : 'Assistant') + '</div><div class="message-content"></div>';
      const contentBlock = div.querySelector('.message-content');
      if (isLast && msg.role === 'assistant' && lastAssistantData && lastAssistantData.text != null) {
        typewriter(contentBlock, lastAssistantData.text || '', stopForHighlight, () => {
          if (lastAssistantData.responseTimeMs != null || (lastAssistantData.usage && lastAssistantData.usage.completion_tokens != null) || lastAssistantData.finish_reason) {
            let html = '';
            if (lastAssistantData.responseTimeMs != null) html += '<dt>Время</dt><dd>' + lastAssistantData.responseTimeMs + ' ms</dd>';
            if (lastAssistantData.usage && lastAssistantData.usage.completion_tokens != null) html += '<dt>Токены в ответе</dt><dd>' + lastAssistantData.usage.completion_tokens + '</dd>';
            if (lastAssistantData.finish_reason) html += '<dt>Причина остановки</dt><dd>' + escapeHtml(lastAssistantData.finish_reason) + '</dd>';
            if (html && metricsEl) { metricsEl.innerHTML = '<dl>' + html + '</dl>'; metricsEl.style.display = 'block'; }
          }
        });
      } else {
        const text = msg.content || '';
        contentBlock.innerHTML = renderMessageContent(text, stopForHighlight && msg.role === 'assistant' && isLast ? stopForHighlight : null);
      }
      wrap.appendChild(div);
    }
    content.innerHTML = '';
    content.appendChild(wrap);
  }

  function renderResultColumn(index, data, responseTimeMs, stopSeqs) {
    const col = getColumnEl(index);
    if (!col) return;
    const content = col.querySelector('.column-content');
    const empty = col.querySelector('.column-empty');
    const metricsEl = col.querySelector('.column-metrics');
    if (empty) empty.style.display = 'none';
    if (content) content.style.display = 'block';
    if (data.error) {
      content.innerHTML = '<div class="error-inline">' + escapeHtml(data.error) + '<br><button type="button" class="btn btn-secondary retry-btn">Retry</button></div>';
      if (metricsEl) metricsEl.style.display = 'none';
      col.querySelector('.retry-btn')?.addEventListener('click', () => document.getElementById('form').requestSubmit());
      return;
    }
    const opts = { text: data.text, stopSequences: stopSeqs || null, responseTimeMs, usage: data.usage, finish_reason: data.finish_reason };
    renderDialogColumn(index, chats[index].messages, opts);
  }

  function simpleLineDiff(a, b) {
    const linesA = a.split(/\n/);
    const linesB = b.split(/\n/);
    const result = [];
    const m = linesA.length, n = linesB.length;
    const lcs = [];
    for (let i = 0; i <= m; i++) { lcs[i] = []; lcs[i][0] = 0; }
    for (let j = 0; j <= n; j++) lcs[0][j] = 0;
    for (let i = 1; i <= m; i++) {
      for (let j = 1; j <= n; j++) {
        if (linesA[i - 1] === linesB[j - 1]) lcs[i][j] = lcs[i - 1][j - 1] + 1;
        else lcs[i][j] = Math.max(lcs[i - 1][j], lcs[i][j - 1]);
      }
    }
    let i = m, j = n;
    const rev = [];
    while (i > 0 || j > 0) {
      if (i > 0 && j > 0 && linesA[i - 1] === linesB[j - 1]) {
        rev.push({ type: 'same', a: linesA[i - 1], b: linesB[j - 1] });
        i--; j--;
      } else if (j > 0 && (i === 0 || lcs[i][j - 1] >= lcs[i - 1][j])) {
        rev.push({ type: 'add', b: linesB[j - 1] });
        j--;
      } else {
        rev.push({ type: 'remove', a: linesA[i - 1] });
        i--;
      }
    }
    return rev.reverse();
  }

  function renderDiffUnified(diff) {
    let html = '';
    diff.forEach(d => {
      if (d.type === 'same') html += '<div>' + escapeHtml(d.a) + '</div>';
      else if (d.type === 'add') html += '<div class="add">+' + escapeHtml(d.b) + '</div>';
      else if (d.type === 'remove') html += '<div class="remove">-' + escapeHtml(d.a) + '</div>';
    });
    return html;
  }
  function renderDiffSplit(diff) {
    let left = '', right = '';
    diff.forEach(d => {
      if (d.type === 'same') {
        left += escapeHtml(d.a) + '\n';
        right += escapeHtml(d.b) + '\n';
      } else if (d.type === 'add') {
        right += '<span class="add">' + escapeHtml(d.b) + '</span>\n';
      } else if (d.type === 'remove') {
        left += '<span class="remove">' + escapeHtml(d.a) + '</span>\n';
      }
    });
    return { left, right };
  }

  let diffMode = 'unified';

  const diffToolbar = document.getElementById('diffToolbar');
  const showDiffBtn = document.getElementById('showDiffBtn');
  const hideDiffBtn = document.getElementById('hideDiffBtn');
  const diffModeSwitch = document.getElementById('diffModeSwitch');
  const diffView = document.getElementById('diffView');
  const diffContent = document.getElementById('diffContent');

  function updateDiffVisibility(show) {
    scrollContainer.style.display = show ? 'none' : 'flex';
    diffView.style.display = show ? 'block' : 'none';
    showDiffBtn.style.display = show ? 'none' : 'inline-block';
    hideDiffBtn.style.display = show ? 'inline-block' : 'none';
    diffModeSwitch.style.display = show ? 'flex' : 'none';
    if (show && chats.length >= 2 && lastResults[0] != null && lastResults[1] != null) {
      const diff = simpleLineDiff(lastResults[0].text || '', lastResults[1].text || '');
      if (diffMode === 'unified') {
        diffContent.innerHTML = '<div class="diff-unified">' + renderDiffUnified(diff) + '</div>';
      } else {
        const { left, right } = renderDiffSplit(diff);
        diffContent.innerHTML = '<div class="diff-split"><div class="side">' + left + '</div><div class="side">' + right + '</div></div>';
      }
    }
  }
  showDiffBtn.addEventListener('click', () => updateDiffVisibility(true));
  hideDiffBtn.addEventListener('click', () => updateDiffVisibility(false));
  document.querySelectorAll('.diff-mode-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      diffMode = btn.getAttribute('data-mode');
      document.querySelectorAll('.diff-mode-btn').forEach(b => { b.setAttribute('aria-pressed', b === btn ? 'true' : 'false'); b.classList.toggle('active', b === btn); });
      updateDiffVisibility(true);
    });
  });

  function addToHistory(user_message, runsConfigs) {
    try {
      let list = [];
      try { list = JSON.parse(localStorage.getItem(STORAGE_KEYS.history) || '[]'); } catch (_) {}
      list.unshift({
        user_message: user_message,
        runs: runsConfigs,
        ts: Date.now(),
      });
      list = list.slice(0, MAX_HISTORY);
      localStorage.setItem(STORAGE_KEYS.history, JSON.stringify(list));
      renderHistory();
    } catch (_) {}
  }

  function renderHistory() {
    const container = document.getElementById('historyList');
    let list = [];
    try { list = JSON.parse(localStorage.getItem(STORAGE_KEYS.history) || '[]'); } catch (_) {}
    if (list.length === 0) {
      container.innerHTML = '<div class="history-empty">Нет записей</div>';
      return;
    }
    container.innerHTML = '';
    list.forEach((item) => {
      const div = document.createElement('div');
      div.className = 'history-item';
      div.tabIndex = 0;
      div.setAttribute('role', 'button');
      div.innerHTML = '<div class="history-item-preview">' + escapeHtml((item.user_message || '').slice(0, 80)) + (item.user_message && item.user_message.length > 80 ? '…' : '') + '</div>';
      div.addEventListener('click', () => restoreHistory(item));
      div.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); restoreHistory(item); } });
      container.appendChild(div);
    });
  }

  function restoreHistory(item) {
    const user_message = item.user_message || '';
    userMessageEl.value = user_message;
    tokenCountEl.textContent = '~' + approxTokens(user_message) + ' токенов';
    if (item.runs && Array.isArray(item.runs) && item.runs.length > 0) {
      chats = item.runs.map((runConfig, idx) => ({
        id: 'chat_' + (nextChatId++),
        name: runConfig.name != null ? runConfig.name : null,
        config: Object.assign(getDefaultConfig(), runConfig.config || {}),
        messages: user_message ? [{ role: 'user', content: user_message }] : [],
      }));
      nextChatId = chats.length;
    } else {
      // legacy: single config
      chats = [{ id: 'chat_0', name: null, config: Object.assign(getDefaultConfig(), {
        system_prompt: item.system_prompt,
        stop_sequences: item.stop_sequences,
        max_output_tokens: item.max_output_tokens,
        model: item.model,
        temperature: item.temperature,
        top_p: item.top_p,
        frequency_penalty: item.frequency_penalty,
        presence_penalty: item.presence_penalty,
        seed: item.seed,
      }), messages: user_message ? [{ role: 'user', content: user_message }] : [] }];
      nextChatId = 1;
    }
    lastResults = [];
    renderChatBlocks();
    renderTabsMobile();
    updateDiffToolbarVisibility();
    closeDrawer();
    saveSettings();
  }

  const drawer = document.getElementById('drawer');
  const drawerBackdrop = document.getElementById('drawerBackdrop');
  document.getElementById('historyBtn').addEventListener('click', () => {
    renderHistory();
    drawer.classList.add('open');
    drawer.setAttribute('aria-hidden', 'false');
    drawerBackdrop.classList.add('open');
    drawerBackdrop.setAttribute('aria-hidden', 'false');
  });
  function closeDrawer() {
    drawer.classList.remove('open');
    drawer.setAttribute('aria-hidden', 'true');
    drawerBackdrop.classList.remove('open');
    drawerBackdrop.setAttribute('aria-hidden', 'true');
  }
  document.getElementById('drawerClose').addEventListener('click', closeDrawer);
  drawerBackdrop.addEventListener('click', closeDrawer);
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && drawer.classList.contains('open')) { closeDrawer(); }
  });

  function updateApiDebugContent(requestBody, responseObj) {
    const section = document.getElementById('apiDebugSection');
    const reqEl = document.getElementById('apiDebugRequest');
    const respEl = document.getElementById('apiDebugResponse');
    if (!section || !reqEl || !respEl) return;
    reqEl.textContent = typeof requestBody === 'string' ? requestBody : JSON.stringify(requestBody, null, 2);
    try {
      respEl.textContent = JSON.stringify(responseObj, null, 2);
    } catch (_) {
      respEl.textContent = String(responseObj);
    }
    section.style.display = 'block';
  }
  document.getElementById('apiDebugToggle').addEventListener('click', () => {
    const content = document.getElementById('apiDebugContent');
    const btn = document.getElementById('apiDebugToggle');
    const open = content.style.display !== 'none';
    content.style.display = open ? 'none' : 'block';
    btn.setAttribute('aria-expanded', open ? 'false' : 'true');
  });

  document.getElementById('form').addEventListener('submit', async (e) => {
    e.preventDefault();
    const user_message = userMessageEl.value.trim();
    if (!user_message) return;

    const continueDialog = document.getElementById('continueDialog').checked;
    const runs = chats.map(chat => {
      const messages = continueDialog ? chat.messages.slice() : [];
      messages.push({ role: 'user', content: user_message });
      return { messages, config: getRunConfig(chat) };
    });
    const payload = { user_message, runs };
    const bodyString = JSON.stringify(payload);

    setStatus('Загрузка…', 'loading');
    document.getElementById('submitBtn').disabled = true;
    chats.forEach((_, i) => showSkeleton(i));
    document.getElementById('diffToolbar').style.display = 'none';
    updateDiffVisibility(false);

    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), FETCH_TIMEOUT_MS);

    const t0 = performance.now();
    try {
      const res = await fetch('/api/compare-many', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: bodyString,
        signal: controller.signal,
      });
      clearTimeout(timeoutId);
      const elapsed = Math.round(performance.now() - t0);
      let data;
      try {
        data = await res.json();
      } catch (_) {
        data = { error: 'Response is not JSON', status: res.status };
      }
      updateApiDebugContent(bodyString, data);
      const errMsg = data.error || String(res.status);
      if (!res.ok) {
        clearTimeout(timeoutId);
        setStatus('Ошибка: ' + errMsg, 'error');
        toast(errMsg || 'Ошибка запроса', true);
        for (let i = 0; i < chats.length; i++) {
          const col = getColumnEl(i);
          if (col) {
            const content = col.querySelector('.column-content');
            const empty = col.querySelector('.column-empty');
            if (content) { content.style.display = 'block'; content.innerHTML = '<div class="error-inline">' + escapeHtml(errMsg) + '</div>'; }
            if (empty) empty.style.display = 'none';
          }
        }
        document.getElementById('submitBtn').disabled = false;
        return;
      }

      const results = data.results || [];
      let hasError = false;
      for (let i = 0; i < chats.length; i++) {
        const r = results[i] || {};
        try {
          if (r.error) {
            hasError = true;
            renderResultColumn(i, r, elapsed, null);
            continue;
          }
          if (continueDialog) {
            chats[i].messages.push({ role: 'user', content: user_message });
            chats[i].messages.push({ role: 'assistant', content: r.text || '' });
          } else {
            chats[i].messages = [{ role: 'user', content: user_message }, { role: 'assistant', content: r.text || '' }];
          }
          lastResults[i] = { text: r.text, usage: r.usage, finish_reason: r.finish_reason };
          const stopSeqs = (chats[i].config && chats[i].config.stop_sequences) ? chats[i].config.stop_sequences : null;
          renderResultColumn(i, { text: r.text, usage: r.usage, finish_reason: r.finish_reason }, elapsed, stopSeqs);
        } catch (colErr) {
          hasError = true;
          renderResultColumn(i, { error: String(colErr && (colErr.message || colErr)) || 'Ошибка отображения' }, elapsed, null);
        }
      }
      if (hasError) setStatus('Частичная ошибка', 'error');
      else setStatus('Готово', '');
      userMessageEl.value = '';
      tokenCountEl.textContent = '~0 токенов';
      addToHistory(user_message, chats.map(c => ({ config: c.config, name: c.name })));
      updateDiffToolbarVisibility();
    } catch (err) {
      clearTimeout(timeoutId);
      const isTimeout = err && (err.name === 'AbortError' || (controller.signal && controller.signal.aborted));
      const errStr = isTimeout ? 'Запрос занял слишком много времени. Попробуйте меньше чатов или повторите позже.' : String(err && (err.message || err) || 'Ошибка');
      updateApiDebugContent(bodyString, { error: errStr });
      setStatus('Ошибка', 'error');
      toast(errStr, true);
      for (let i = 0; i < chats.length; i++) {
        const col = getColumnEl(i);
        if (col) {
          const content = col.querySelector('.column-content');
          const empty = col.querySelector('.column-empty');
          if (content) { content.style.display = 'block'; content.innerHTML = '<div class="error-inline">' + escapeHtml(errStr) + '<br><button type="button" class="btn btn-secondary retry-btn">Retry</button></div>'; }
          if (empty) empty.style.display = 'none';
          col.querySelector('.retry-btn')?.addEventListener('click', () => document.getElementById('form').requestSubmit());
        }
      }
    } finally {
      document.getElementById('submitBtn').disabled = false;
    }
  });

  const evalSection = document.getElementById('evalSection');
  const evalWinner = document.getElementById('evalWinner');
  const evalRanking = document.getElementById('evalRanking');
  const evalDetails = document.getElementById('evalDetails');
  const evalBadges = document.getElementById('evalBadges');

  const CRITERION_LABELS_RU = {
    correctness: 'Правильность',
    completeness: 'Полнота',
    relevance: 'Релевантность',
    clarity: 'Ясность',
    actionability: 'Действенность',
    constraint_following: 'Соблюдение ограничений',
    uncertainty_handling: 'Работа с неопределённостью',
    safety: 'Безопасность',
    efficiency: 'Эффективность',
  };
  function criterionLabel(key) { return CRITERION_LABELS_RU[key] || key; }

  function buildEvalRuns() {
    const runs = [];
    for (let i = 0; i < chats.length; i++) {
      const text = lastResults[i] && lastResults[i].text != null ? lastResults[i].text : (chats[i].messages.length > 0 && chats[i].messages[chats[i].messages.length - 1].role === 'assistant' ? chats[i].messages[chats[i].messages.length - 1].content : '');
      runs.push({
        run_id: String(i),
        answer_text: text || '',
        latency_ms: lastResults[i] && lastResults[i].responseTimeMs != null ? lastResults[i].responseTimeMs : null,
        tokens_out: lastResults[i] && lastResults[i].usage && lastResults[i].usage.completion_tokens != null ? lastResults[i].usage.completion_tokens : null,
      });
    }
    return runs;
  }

  function renderEvalReport(report) {
    if (!report) return;
    evalSection.style.display = 'block';
    const winnerId = report.winner_run_id;
    const ranking = report.ranking || [];
    const perRun = report.per_run || {};
    const rankIndex = ranking.indexOf(winnerId);
    const winnerIdx = parseInt(winnerId, 10);
    const winnerLabel = rankIndex >= 0 && chats[winnerIdx] ? getChatLabel(chats[winnerIdx], winnerIdx) : winnerId;
    evalWinner.textContent = 'Победитель: ' + winnerLabel + (perRun[winnerId] ? ' (' + Math.round(perRun[winnerId].overall_score) + ')' : '');
    evalBadges.innerHTML = '';
    const conf = document.createElement('span');
    conf.className = 'eval-badge confidence';
    conf.textContent = 'Уверенность: ' + Math.round((report.confidence || 0) * 100) + '%';
    evalBadges.appendChild(conf);
    if (report.is_fallback) {
      const fb = document.createElement('span');
      fb.className = 'eval-badge fallback';
      fb.textContent = 'Эвристика';
      evalBadges.appendChild(fb);
    }
    let tableHtml = '<table class="eval-table"><thead><tr><th>#</th><th>Чат</th><th class="eval-th-score">Балл</th></tr></thead><tbody>';
    ranking.forEach((runId, i) => {
      const pr = perRun[runId];
      const score = pr ? Math.round(pr.overall_score) : '—';
      const idx = parseInt(runId, 10);
      const label = chats[idx] ? getChatLabel(chats[idx], idx) : runId;
      tableHtml += '<tr><td>' + (i + 1) + '</td><td>' + escapeHtml(label) + '</td><td class="eval-td-score">' + score + '</td></tr>';
    });
    tableHtml += '</tbody></table>';
    evalRanking.innerHTML = '<h3 class="eval-subtitle">Ранжирование</h3>' + tableHtml;
    let detailsHtml = '<h3 class="eval-subtitle">Подробности по ответам</h3>';
    ranking.forEach((runId) => {
      const pr = perRun[runId];
      if (!pr) return;
      const idx = parseInt(runId, 10);
      const label = chats[idx] ? getChatLabel(chats[idx], idx) : runId;
      const id = 'eval-run-' + runId;
      let body = '';
      if (Object.keys(pr.per_criterion_scores || {}).length) {
        body += '<dl><dt>Критерии</dt><dd><ul class="eval-criteria-list">';
        for (const [k, v] of Object.entries(pr.per_criterion_scores)) {
          body += '<li>' + escapeHtml(criterionLabel(k)) + ': ' + v + '</li>';
        }
        body += '</ul></dd></dl>';
      }
      if ((pr.strengths || []).length) { body += '<dl><dt>Сильные стороны</dt><dd><ul class="eval-criteria-list">'; pr.strengths.forEach(s => { body += '<li>' + escapeHtml(s) + '</li>'; }); body += '</ul></dd></dl>'; }
      if ((pr.weaknesses || []).length) { body += '<dl><dt>Слабости</dt><dd><ul class="eval-criteria-list">'; pr.weaknesses.forEach(w => { body += '<li>' + escapeHtml(w) + '</li>'; }); body += '</ul></dd></dl>'; }
      if ((pr.fix_suggestions || []).length) { body += '<dl><dt>Рекомендации</dt><dd><ul class="eval-criteria-list">'; pr.fix_suggestions.forEach(f => { body += '<li>' + escapeHtml(f) + '</li>'; }); body += '</ul></dd></dl>'; }
      detailsHtml += '<div class="eval-run-card"><button type="button" class="eval-run-header" aria-expanded="false" aria-controls="' + id + '" data-run-id="' + escapeHtml(runId) + '">' + escapeHtml(label) + ' — ' + Math.round(pr.overall_score) + ' <span aria-hidden="true">▼</span></button><div class="eval-run-body" id="' + id + '" style="display:none;">' + body + '</div></div>';
    });
    if (report.top2_comparison) {
      const top2 = report.top2_comparison;
      detailsHtml += '<h3 class="eval-subtitle eval-subtitle-top2">Сравнение топ-2</h3><div class="eval-top2-card"><div class="eval-run-body"><dl><dt>Почему победитель лучше</dt><dd>' + escapeHtml(top2.why_winner_better) + '</dd><dt>Где второй лучше</dt><dd>' + escapeHtml(top2.where_runner_up_better) + '</dd></dl></div></div>';
    }
    evalDetails.innerHTML = detailsHtml;
    evalDetails.querySelectorAll('.eval-run-header').forEach(btn => {
      btn.addEventListener('click', () => {
        const body = document.getElementById(btn.getAttribute('aria-controls'));
        if (!body) return;
        const open = body.style.display !== 'none';
        body.style.display = open ? 'none' : 'block';
        btn.setAttribute('aria-expanded', open ? 'false' : 'true');
        const span = btn.querySelector('span');
        if (span) span.textContent = open ? '▼' : '▲';
      });
    });
  }

  document.getElementById('evaluateBtn').addEventListener('click', async () => {
    const runs = buildEvalRuns();
    if (runs.length === 0 || runs.every(r => !(r.answer_text || '').trim())) {
      toast('Сначала запустите сравнение и получите ответы', true);
      return;
    }
    const user_message = userMessageEl.value.trim();
    const preset = document.getElementById('evalPreset').value || 'general';
    setStatus('Оценка…', 'loading');
    document.getElementById('evaluateBtn').disabled = true;
    try {
      const res = await fetch('/api/evaluate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ user_message: user_message || 'No question', runs: runs, weights_preset: preset }),
      });
      const data = await res.json();
      if (!res.ok) {
        toast(data.error || 'Ошибка оценки', true);
        setStatus('Ошибка', 'error');
        return;
      }
      renderEvalReport(data);
      setStatus('Готово', '');
    } catch (err) {
      toast(String(err.message || err), true);
      setStatus('Ошибка', 'error');
    } finally {
      document.getElementById('evaluateBtn').disabled = false;
    }
  });

  document.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) {
      e.preventDefault();
      document.getElementById('form').requestSubmit();
    }
    if (e.key === 'k' && (e.metaKey || e.ctrlKey)) {
      e.preventDefault();
      userMessageEl.value = '';
      tokenCountEl.textContent = '~0 токенов';
      saveSettings();
    }
  });

  renderChatBlocks();
  renderTabsMobile();
  updateDiffToolbarVisibility();
  renderHistory();
})();
  </script>
</body>
</html>
